const num: int :: 5000
var drawMain: wnd@Draw
const number: []char :: "0123456789"
func main()
	var gra: dict<int, draw@Tex> :: #dict<int, draw@Tex>
	var snd: dict<int, snd@Snd> :: #dict<int, snd@Snd>
	do ogg@init()
	var wndMain: wnd@Wnd :: wnd@makeWnd(null, %fix, 1280, 720, "SeisoHack")
	do @drawMain :: wnd@makeDraw(wndMain, 0, 0, 1280, 720, %fix, %fix, false)
	do wndMain.onActivate :: pop
	func pop(wnd: wnd@WndBase, a: bool, b: bool)
		if(a = true & b = false)
			do @drawMain.focus()
		end if
	end func
	;do draw@clearColor(0xFF000000)
	;do draw@autoClear(false)
	do draw@sampler(%point)
	do @drawMain.focus()
	
	var handle: file@Reader :: file@makeReader("res/start.txt")
	do handle.delimiter("")
	var srcc: []char :: handle.readStr().replace("\n", "").replace("\t", "")
	do handle.fin()
	
	var src: [][]char
	var lsrc: list<[]char> :: #list<[]char>
	var cnt: int :: 0
	
	while lp(cnt < ^srcc)
		if(("+-[]><.,opPsSzr=^m{}" ~ @number).findStr(srcc[cnt].toStr(), -1) > -1)
			var t: char :: srcc[cnt]
			if(cnt + 1 < ^srcc & @number.findStr(srcc[cnt + 1].toStr(), -1) > -1)
				var num: []char :: ""
				var p: int :: 1
				while(cnt + p < ^srcc & @number.findStr(srcc[cnt + p].toStr(), -1) > -1)
					do num :: num ~ srcc[cnt + p].toStr()
					do p :+ 1
				end while
				do lsrc.add(t.toStr())
				do lsrc.add(num)
				do cnt :+ p - 1
			else
				do lsrc.add(srcc[cnt].toStr())
				;do cui@print(srcc[cnt].toStr())
			end if
		end if
		do cnt :+ 1
	end while
	do src :: lsrc.toArray()
	
	var jumpPos: []int :: #[^src]int
	for n(0, ^src - 1)
		;do cui@print("\{src[n]} ")
		
		if(src[n] = "[")
			var pos: int :: n
			var m: int :: 0
			while lpp(true)
				if(pt >= ^src)
					ret
				end if
				if(src[pos] = "[")
					do m :+ 1
				end if
				if(src[pos] = "]")
					do m :- 1
				end if
				if(m = 0)
					do jumpPos[n] :: pos
					break lpp
				end if
				do pos :+ 1
			end while
		elif(src[n] = "]")
			var pos: int :: n
			var m: int :: 0
			while lpp(true)
				if(pt < 0)
					ret
				end if
				if(src[pos] = "[")
					do m :+ 1
				end if
				if(src[pos] = "]")
					do m :- 1
				end if
				if(m = 0)
					do jumpPos[n] :: pos
					break lpp
				end if
				do pos :- 1
			end while
		elif(src[n] = "{")
			var pos: int :: n
			var m: int :: 0
			while lpp(true)
				if(pt >= ^src)
					ret
				end if
				if(src[pos] = "{")
					do m :+ 1
				end if
				if(src[pos] = "}")
					do m :- 1
				end if
				if(m = 0)
					do jumpPos[n] :: pos
					break lpp
				end if
				do pos :+ 1
			end while
		elif(src[n] = "}")
			var pos: int :: n
			var m: int :: 0
			while lpp(true)
				if(pt < 0)
					ret
				end if
				if(src[pos] = "{")
					do m :+ 1
				end if
				if(src[pos] = "}")
					do m :- 1
				end if
				if(m = 0)
					do jumpPos[n] :: pos
					break lpp
				end if
				do pos :- 1
			end while
		end if
	end for
	var mem: []int :: #[@num]int
	var px: int :: 0
	var pt: int :: 0
	var tmp: int :: 0
	var st: stack<int> :: #stack<int>
	while lp(pt < ^src)
		if(wnd@act() = false)
			ret
		end if
		var nflg: bool :: false
		var num: int :: 0
		if(pt < ^src - 1)
			if(@number.findStr(src[pt + 1][0].toStr(), -1) > -1)
				do nflg :: true
				do num :: src[pt + 1].toInt(&)
			end if
		end if
		switch(src[pt])
		case ">"
			do px :+ 1
			if(px >= @num)
				ret
			end if
		case "<"
			do px :- 1
			if(px < 0)
				ret
			end if
		case "+"
			if(nflg = true)
				do mem[px] :+ num
				do pt :+ 1
			else
				do mem[px] :+ 1
			end if
		case "-"
			if(nflg = true)
				do mem[px] :- num
				do pt :+ 1
			else
				do mem[px] :- 1
			end if
		case "."
			do draw@render(60)
			if(dbg = true)
				do cui@print("\{mem[px]} ")
			end if
		case "^"
			if(nflg = true)
				do st.add(num)
			elif(src[pt + 1] = "m")
				do st.add(mem[px])
			elif(src[pt + 1] = ">")
				var a1: int :: st.get()
				if(mem[px] > a1)
					do tmp :: 1
				else
					do tmp :: 0
				end if
			elif(src[pt + 1] = "<")
				var a1: int :: st.get()
				if(mem[px] < a1)
					do tmp :: 1
				else
					do tmp :: 0
				end if
			elif(src[pt + 1] = "=")
				var a1: int :: st.get()
				if(mem[px] = a1)
					do tmp :: 1
				else
					do tmp :: 0
				end if
			end if
			do pt :+ 1
		case ","
			var key: []input@PadBtn :: [%down $ input@PadBtn, %up, %left, %right, %a, %b, %c, %d, %e, %f]
			do mem[px] :: input@pad(0, key[mem[px]])
		case "["
			if(mem[px] = 0)
				do pt :: jumpPos[pt] - 1
			end if
		case "]"
			do pt :: jumpPos[pt]
		case "{"
			if(tmp = 0)
				do pt :: jumpPos[pt] - 1
			end if
		case "}"
		case "o"
			if(mem[px] = 0)
				do bgm@stop()
			else
				do bgm@play("res/mus/\{mem[px]}.ogg", 0.0)
			end if
		case "p"
			var o: draw@Tex :: gra.get(mem[px], &)
			do o.draw(mem[px + 1] $ float, mem[px + 2] $ float, 0.0, 0.0, o.imgWidth() $ float, o.imgHeight() $ float, draw@white)
		case "P"
			do gra.add(mem[px], draw@makeTex("res/img/\{mem[px]}.png"))
		case "s"
			var o: snd@Snd :: snd.get(mem[px], &)
			do o.setPos(0.0)
			do o.play()
		case "S"
			do snd.add(mem[px], snd@makeSnd("res/img/\{mem[px]}.wav"))
		case "z"
			do mem[px] :: 0
		case "r"
			do px :: 0
		default
		end switch
		do pt :+ 1
	end while
end func
